var store = [{
        "title": "Markdown: Sintáxis básica",
        "excerpt":"Sintáxis básica en Jekyll - Markdown Texto             Objeto      ¿Cómo?                  Salto de línea      Doble espacio              Link      [texto](http://example.com)              Destacar      `palabra(s)`              —Cita      —&lt;cite&gt;Cita&lt;/cite&gt;              enfatizar      _enfatizar_              Negrita      **Negrita**      Header one # Header one Header two ## Header two Header three ### Header three Header four #### Header four Header five ##### Header five Header six ###### Header six Blockquotes Una línea blockquote:   Divide y vencerás &gt; Divide y vencerás Multi line blockquote with a cite reference:   La gente malgasta su tiempo y luego quieren más.Quieren días con más horas, años con más días, vidas con más años.Porque si tuvieran ese tiempo de más podrían corregir cualquier error.   Ekko &mdash; La verdad sobre el tiempo es esta: si no puedes sacarle todo el partido a un momento dado, no te mereces ni un segundo de más.&gt; La gente malgasta su tiempo y luego quieren más.&gt; Quieren días con más horas, años con más días, vidas con más años.&gt; Porque si tuvieran ese tiempo de más podrían corregir cualquier error.&gt; &lt;footer&gt;&lt;strong&gt;Ekko&lt;/strong&gt; &amp;mdash; No necesito horas ni días ni años... solo unos segundos&lt;/footer&gt;Tablas             Header1      Header2      Header3                  cell1      cell2      cell3              cell4      cell5      cell6                  cell1      cell2      cell3              cell4      cell5      cell6                  Foot1      Foot2      Foot3      | Header1 | Header2 | Header3 ||:--------|:-------:|--------:|| cell1   | cell2   | cell3   || cell4   | cell5   | cell6   ||-----------------------------|| cell1   | cell2   | cell3   || cell4   | cell5   | cell6   ||=============================|| Foot1   | Foot2   | Foot3   |Listas desordenadas (anidada)   List item one          List item one                  List item one          List item two          List item three          List item four                    List item two      List item three      List item four        List item two  List item three  List item fourListas ordenadas (anidada)   List item one          List item one                  List item one          List item two          List item three          List item four                    List item two      List item three      List item four        List item two  List item three  List item four  * List item one       * List item one           * List item one          * List item two          * List item three          * List item four      * List item two      * List item three      * List item four  * List item two  * List item three  * List item four  1. List item one       1. List item one           1. List item one          2. List item two          3. List item three          4. List item four      2. List item two      3. List item three      4. List item four  2. List item two  3. List item three  4. List item fourDirecciones   Calle de la piruleta Casa de la gominola País FelizAbreviación La abreviación de CSS  “Cascading Style Sheets”.*[CSS]: Cascading Style Sheets La abreviación de CSS  \"Cascading Style Sheets\".*[CSS]: Cascading Style SheetsCita “Esto es una cita” —Pepe \"Esto es una cita\" ---&lt;cite&gt;Pepe&lt;/cite&gt;","categories": ["Jekyll"],
        "tags": ["Jekyll","markdown","md"],
        "url": "https://noobchamp.github.io/jekyll/sintaxis-basica/"
      },{
        "title": "Jekyll: Crea tu web/blog en pocos minutos con Jekyll",
        "excerpt":"¿Qué es Jekyll? Ir al granoJekyllrb se define como un generador de sitios web estáticos.Principalmente se tratan de blogs o páginas webs en las que no es necesario tener una base de datos. Por ejemplo, si una persona quiere una página web para su restaurante, peluquería, taller o cualquier otro negocio en la que simplemente se usa para tener una “imagen de empresa” en internet. Webs en las que se publicitan servicios, precios, horarios, contacto, etc… En mi caso particular (y para lo que habitualmente se usa) he construido un blog. En pocos minutos y sin necesidad de ningún tipo de inversión económica…GRATIS, la palabra favorita de cualquiera. Cada post o contenido agregado por el usuario está escrito en archivos Markdown o md. El formato viene dado por plantillas HTML y CSS.Jekyll está escrito en Ruby pero prácticamente no es necesario saber nada sobre este particular lenguaje de programación. Es necesario modificar algunos parámetros de configuración pero el sistemas de plantillas de Jekyll hace que sea realmente fácil para cualquier persona incluso con un conocimiento básico de informática. Por supuesto este blog está hecho con Jekyll y voy a enseñarte en pocos paso como puedes crear el tuyo.En mi caso, lo uso para propósito de aprendizaje y modo de documentación donde de paso otras personas puedan leer y aprender. Alguno que otro se pasará a criticarlo. Todos son bienvenidos. Si quieres saber más sobre Jekyll puedes pasarte por su página oficial y echar un vistazo. Esta todo en Inglés, si no estás familiarizado seguro que encuentras decenas de tutoriales por la red, en Youtube y otras plataformas en castellano. ¿Por qué Jekyll y no un CMS? A mi modo de ver casi nunca nada es mejor que otra cosa o al menos en este mundillo con tecnologías similares. Siempre vas a oir cosas como este lenguaje de programación es mejor que este…. Esta plataforma es mejor que esta… No es mi caso.Elegí Jekyll antes que otro CMS por varias razones:   Rápida instalación y configuración.  No es necesario manejar una base de datos.  Estoy empezando a odiar los backends.  Para mí, al menos ahora es novedad (aunque lleva muchos años existiendo).  Me permite publicarlo gratis mediante GITHUB  Decenas de plantillas gratuitas optimizadas en cuanto a SEO y texto enriquecido.Yo te diría que al menos le des una oportunidad e investigues un poco si alguno de los puntos anteriores encajan en tu carácter. Instalación Requisitos Tener instalado Ruby Windows: Descarga e instala Ruby+Devkit desde la página de descargas de RubyInstaller (instalaciones de Windows siempre es presionar Sí a todo). En mi caso usé Ruby+Devkit 2.7.2-1 (x64). Al final de la instalación se abrirá un terminal en el que te pide elegir entre 3 opciones. Elige la 1 y presiona Enter para finalizar la instalación. Linux: Ubuntu o según tu distro Tener instalado Jekyll y Bundler Abre un nuevo terminal y teclea (En la barra de búsqueda de Windows busca “Símbolo del sistema”): gem install jekyll bundler  Finalmente comprueba que todo es correcto abriendo una nueva terminal y tecleando  jekill -vEn Windows tal vez es necesario reiniciar (ya conocemos a Windows) para aplicar cambios. Si no te aclaras o necesitas más información te dejo el link oficial para la instalación de Jekyll. Es bastante completa, clara y concisa. Crear el sitio En este momento ya disponemos de lo necesario para crear nuestro primer blog/sitio web.Para los siguientes pasos puedes usar editor de código (A mi en particular me gusta Visual Code Studio){:.link} o la misma terminal de Windows. Para el ejemplo vamos a iniciar un nuevo terminal de windows, por defecto se sitúa en el directorio del usuario actual “C:\\Users\\Usuario&gt;” y tecleamos: jekyll new nombre-sitionombre-sitio o lo que quieras llamarle (blog, miblog, misitio….) Se va a crear el sistema de archivos correspondiente y tenemos que desplazarnos a ese directorio: cd nombre-sitioLevantar el servicio en local Ahora simplemente vamos a arrancar un servidor local para visualizar nuestro primer sitio con Jekyll bundle exec jekyll serveTe responderá con algo como:Server address: http://127.0.0.1:4000 Pinchamos sobre el enlace o abrimos nuestro navegador con al url localhost:4000 ¡Listo!, ya tienes creado tu sitio     127.0.0.1:4000Primer post y configuración inicial En ese punto ya tenemos corriendo el servidor en local, con un primer post de ejemplo. El árbol de directorio debe ser similar al de la imagen de la derecha.En principio vamos a fijarnos en el directorio _post, el archivo _config.yml y el archivo about.markdown. Estos dos últimos están ubicados en la raíz del proyecto. _post En este directorio se almacenan los post a publicar. Hay que seguir una sintáxis ordenada, en cada nuevo post será guardado con el formato: formato: AAAA-mm-dd-nombre-articulo.markdownejemplo: 2021-12-31-pandemia-covid-19-erradicada.markdownSi compruebas el archivo de ejemplo creado 2021-04-08-welcome-to-jekyll.markdown podrás ver que comienza con la siguiente cabecera: ---layout: posttitle:  \"Welcome to Jekyll!\"date:   2021-04-08 14:18:40 +0200categories: jekyll update---Debes respetar los 3 guiones al inicio y al final. Esta cabecera te puede guiar como plantilla, añade tu título, fecha de creación, categoría(s) y escribe el cuerpo del artículo o rellena con un poco de texto. Guarda los cambios y vuelve a tu página localhost (¡Puedes hacer click en este enlace!). ---layout: posttitle:  \"¡Adiós al Covid!\"date:   2020-12-31 00:00:00 +0200categories: Covid---# Al fin!!El COVID-19 es historia.Yo he escrito este artículo. Haz el tuyo propio o copia este código y visualiza los cambios en tu entorno.Cuidado si al guardar los cambios o relanzar el comando bundle exec jekyll serve nos devuelve algún error, por ejemplo, si la fecha es posterior a la actual. _config.yml title: Your awesome titleemail: your-email@example.comdescription: &gt;- # this means to ignore newlines until \"baseurl:\"  Write an awesome description for your new site here. You can edit this  line in _config.yml. It will appear in your document head meta (for  Google search results) and in your feed.xml site description.baseurl: \"\" # the subpath of your site, e.g. /blogurl: \"\" # the base hostname &amp; protocol for your site, e.g. http://example.comtwitter_username: jekyllrbgithub_username:  jekyll# Build settingstheme: minimaplugins:  - jekyll-feedEsta parte no es un poema….no es muy difícil entender, por el momento puedes cambiar el título de tu sitio, configurar tu email, hacer una descripción y agregar si quieres tu usuario de Twitter y Github (si quieres).Al tratarse de una archivo de configuración tenemos que volver a compilar. Lanzamos el comando bundle para recompilar nuestro sitio y luego nuevamente levantamos el servidor local. about.markdown Se trata de la página “about” de nuestro sitio. Tienes una pequeña pista de como utilizar formato para enlaces: [jekyllrb.com](https://jekyllrb.com/)Se trata de un enlace a jekyllrb.com ¿Esto es todo? En este punto ya tienes un nuevo sitio, con una configuración inicial, un nuevo post original y una página “about”. Pues… de momento no es muy atractivo que digamos. Hay que cambiar el estilo, agregar nuevas páginas como “post, tags, etc”, aún hay que publicarlo en internet GRATIS como se había prometido….No te preocupes, no era un clip bait cuando al principio te indicaba que era rápido de iniciar y que podrías publicarlo totalmente gratis pero este artículo se está alargando demasiado y mi intención era familiarizarte con Jekyll y entender el funcionamiento. ¿Y si te dijera que todo lo anterior no vale absolutamente para nada? Porque hay maneras (y muchas) más sencillas de crear el sitio/blog con su estilo, pestañas, configuración adicional…etc. Podemos hacer nuestro sitio partiendo desde una plantilla lo que nos va a permitir ahorrarnos todo esto que hemos visto. Por tanto, es hora de elegir plantilla. Desde el sitio oficial de jekyll nos ofrecen varios enlaces donde podremos encontrar cientos de plantillas GRATIS … otra vez … GRATIS. Los enlaces son los siguientes:   jamstackthemes  jekyllthemes  jekyllthemes  jekyll-themesElige una de las plantillas gratuitas para proseguir. Te espero en el siguiente artículo. Te sigo ","categories": ["Jekyll"],
        "tags": ["Jekyll","Ruby","Github"],
        "url": "https://noobchamp.github.io/jekyll/crear-un-sitio-web-estatico-gratis-jekyll/"
      },{
        "title": "Jekyll: Crea tu blog Jekyll desde una plantilla",
        "excerpt":"Introducción En un artículo anterior hemos creado nuestro primer blog/sitio.Ahora vamos a crear un blog partiendo desde una plantilla, por tanto como otros CMS nos va a proporcionar la mayoría del trabajo en cuanto a:   Estilos  Rutas  Configuración  SEO  Javascript  Tags  Y un largo etcRequisitos previos Esto son los requisitos previos impuestos para este artículo, ya que puedes hacerlo de varias maneras. Yo voy a realizar un fork sobre el repositorio de Github de la plantilla que me interesa. Podrías copiar directamente el directorio pero vas a necesitar al menos estos requisitos para el siguiente paso publicarlo gratuitamente en internet.   Tener cuenta en Github  GIT instalado.Si no estás familiarizado con git no es mayor problema, solo vamos a hacer git clone.He tomado de ejemplo Agus Makmun, es una plantilla sencilla y fácil de entender para un inicio. Si quieres seguir los mismos pasos pincha en el enlace. Realizar un fork Cuando estemos en el repositorio de la plantilla que hayas elegido, en la esquina superior derecha, bajo tu foto de perfil de Github verás lo siguiente:  Presiona sobre FORK y el repositorio se copiará automáticamente como un repositorio tuyo. Traer el proyecto a local Ahora si vamos a necesitar git. Abre una nueva consola y situate donde quieras clonar los archivos a tu PC. Ejecuta: git clone https://github.com/username/agusmakmun.github.io.gitTras esto, nos desplazamos dentro del proyecto agusmakmun.github.io.git y siguiendo las instrucciones del creador tecleamos en la consola: bundle updatejekyll serveAbre en tu navegador localhost:4000¡Y ya está!, ya tenemos todo lo que hicimos en el artículo anterior pero con las ventajas de una plantilla. En el siguiente artículo vamos a publicar gratis nuestro proyecto y además vamos a realizar una integración contínua. ¿Te vienes? Voy para alla! ","categories": ["Jekyll"],
        "tags": ["Jekyll","Ruby","Github"],
        "url": "https://noobchamp.github.io/jekyll/crear-blog-jekyll-desde-plantilla/"
      },{
        "title": "Jekyll: Publicar tu blog gratis en Github e integración contínua (CI)",
        "excerpt":"Introducción En el artículo anterior vimos como crear una un blog haciendo un fork en el repositorio del creador.  Además iniciamos el sitio web en un entorno local e hicimos algunos ajustes, además creamos un nuevo post.Veremos que cuando creemos el sitio, cada vez que creemos un nuevo post no se va a actualizar en Github. Para ello contamos con un script que va a reconstruir el sitio para cada pushque lancemos. Requisitos   Tener cuenta en Github  Conocimientos básicos de Git  Un poco de ilusiónPasos previos. Dentro la raíz de nuestro repositorio agusmakmun.github.io (en nuestro caso puesto que creamos la plantilla a partir de este repositorio) vamos a realizar git push.Comprobamos que en nuestro proyecto LOCAL, en el archivo _config.yml situado en la raíz tiene la URL configurada como username.github.io.Ahora vamos a actualizar nuestro repositorio, simplemente en el terminal ejecutamos los comandos: git add .git commit -m \"primer commint\"  git pushY comprobamos en nuestra cuenta que los cambios que hemos realizado en nuestro proyecto local como nuestro primer post ¡Adiós al Covid!. Crear una nueva rama (branch) En la pestaña “Master” hacemos click y ponemos en el cuadro de diálogo gh-pages, luego a “crear rama a partir de Master”. Esta rama es la que vamos a indicar a Github que vamos a publicar.Así es, no vas a publicar rama principal sino una rama creada a partir de la “Master” y en los siguientes pasos vamos a ver como actualizarla cada vez que realizamos un push. Configuración Ahora vamos a la configuración del proyecto y lo renombramos cono “usuario.github.io”, es decir, cambiamos el nombre de “agusmakmun” a tu nombre de usuario. Envioroments Ve a la pestaña “envioroments” y crea uno nuevo. Puedes ponerle de nombre “gh-page” Pages Por último nos vamos a la pestaña “pages” y configuramos la rama a usar gh-pages. Test En estos momentos tu sitio web debe estar actualizado y deberías poder acceder a la URL username.github.io. Éxito -&gt; Puedes ver blog creado con Jekyll publicado en internet al alcance de cualquier interesado.Fracaso -&gt; Puede que no hayas realizado un paso bien. Repito los pasos.Ni blanco ni negro -&gt; Tu sitio web se visualiza pero no tiene formato [CSS]. En este caso comprueba que en el archivo _config.yml no tienes configurado la opción baseurl. A no ser que tu proyecto esté en un subdirectorio como “/blog”.*[CSS]: Cascading Style Sheets Integración contínua En estos momentos si creamos un nuevo post en nuestro proyecto local y hacemos “push” para actualizar nuestro repositorio. Vamos a comprobar que nuestro sitio username.github.io no se actualiza. Tienes que crear una carpeta dentro de tu proyecto llamada .github –con el “.” punto delante. Dentro de ella creamos otra carpeta llamada workflosy dentro de esta carpeta creamos el archivo main.yml. on:  push:    branches:      - masterjobs:  build_and_deploy:    runs-on: ubuntu-latest    steps:      - name: GitHub Checkout        uses: actions/checkout@v1      - name: Bundler Cache        uses: actions/cache@v1        with:          path: vendor/bundle          key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}          restore-keys: |            ${{ runner.os }}-gems-      - name: Build &amp; Deploy to GitHub Pages        uses: joshlarsen/jekyll4-deploy-gh-pages@master        env:          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}          GITHUB_REPOSITORY: ${{ secrets.GITHUB_REPOSITORY }}          GITHUB_ACTOR: ${{ secrets.GITHUB_ACTOR }}   Al realizar nuevamente los comandos git y subir el archivo podremos ver los cambios en la pestaña “actions” de nuestro proyecto.Y no me voy a enrollar más sobre como funciona el archivo, si estás interesado házmelo saber mediante comentarios y poder subir otro artículo más dedicado a la integración contínua. También podéis dirigiros al repositorio original joshlarsen para leer la documentación completa. Espero que te haya servido de ayuda. ","categories": ["Jekyll"],
        "tags": ["Jekyll","Ruby","Github"],
        "url": "https://noobchamp.github.io/jekyll/Jekyll-publicar-gratis-ci/"
      },{
        "title": "Prompt: Personaliza el prompt de tu Linux",
        "excerpt":"Prompt A menudo tenemos varios terminales abiertos y la Shell de Linux suele ser siempre la misma por norma general. username@hostname$Varía un poco según la distro o según si el usuario que usamos es root u otro distinto. ¿Cuál es el propósito En muchas ocasiones nos movemos contínuamente por ejemplo de servidores de producción a desarrollo o simplemente tenemos varios terminales en los que solemos trabajar a lo largo del día.Durante algunos años estuve trabajando como administrador de sistemas realizando contínuos despliegues. Llega el momento en el que te confundes a la hora de reiniciar un servicio, realizar copias y consultas varias entre el servidor de producción y el servidor pre-producción puesto que suelen ser idénticos y la información se suele desplazar del segundo al primero una vez se ha verificado todo. ¿A nadie le ha ocurrido reiniciar un proceso en producción creyendo que se trataba del servidor de pre-producción o desarrollo? A mí unas cuantas, así que empecé a personalizar el prompt para evitar este tipo de errores.Como idea, puedes incluirlo en un script para cuando recibes acceso a un servidor. A lo largo del tiempo verás que es rentable ya que siempre vas a realizar tareas iniciales como esta además de otras como configurar una clave ssh o hacer un diagnóstico inicial del sistema. Vamos al grano Hay decenas de páginas web para hacer esta tarea más sencilla. Si quieres seguir mi ejemplo entra en bashrcgenerator.  Personalizando el prompt de Debian Ahora tienes que copiar el resultado de la casilla 4.Como puedes observar *?* no nos dice nada, eso vamos a cambiarlo por PRODUCCIÓN, DESARROLLO o la etiqueta que quieras poner para identificarlo en todo momento.En la Shell, edita el archivo .bashrc de tu home: vi ~/.bashrcSi no sabes usar el editor de VI, usa nano o el que prefierasPega el código copiado anteriormente y sustituye ? como indicaba anteriormente. Tras esto tienes que salir y volver a entrar o simplemente usa el comando: source ~/.bashrc¡Espero que te sirva de algo!Saludos. ","categories": ["Linux"],
        "tags": ["Linux","Prompt","Debian"],
        "url": "https://noobchamp.github.io/linux/prompt-linux-personalizado/"
      },{
        "title": "FreeSwitch: Instalación sobre Debian 10 Buster",
        "excerpt":"Introducción FreeSwitch es una plataforma de telefonía de código abierto.Es realmente flexible gracias a su buen rendimiento. Se puede usar como PBX, como un soft-switch. Podríamos usarla para distintos propósitos como por ejemplo un SBC entre otras centralitas físicas o virtuales como Alcatel, Panasonic, Avaya, Asterisk, etc. Podríamos instalar una GUI para usar como PBX. Podríamos usarlo para control de facturación entre distintos clientes y proveedores, es decir, balancear nuestras llamadas por coste de todos nuestros clientes además de muchas más cosas. FreeSwitch es muy versátil. Es posible instalar FreeSwitch desde una Raspberry hasta un buen servidor físico, va a depender de la carga. Lo mejor de todo es que es escalable, por lo que podríamos ampliar en cualquier momento. Objetivos del aprendizaje No vamos a entrar en profundidad en definiciones o aspectos técnicos sobre VoIP. En internet se puede encontrar numerosos sitios donde explican conceptos de telefonía como:   Protocolo SIP  Códecs  Wireshark  TCPdump  Aplicaciones de PBX  Softphone  LUA  XML  Otras cosasVamos a instalar FreeSwitch y empezar a “trastearlo” todo para entender como funciona y que ventajas nos puede ofrecer. Así pues…¡Vamos al lío! Instalación de FreeSwitch En nuestro ejemplo vamos a instalar FreeSwitch sobre Debian 10 Buster, de forma local a través de una máquina virtual en red interna. Ya te voy avisando que si usas arquitectura i386 no te va a funcionar. Tienes el enlace a la versión 10.9 amd64. Máquina virtual:   4Gb Ram  16Gb Almacenamiento  2 Procesadores  Adaptador puente IP 192.168.0.15  Sin escritorio  SSH ServerCon eso vamos a tirar de momento. Más adelante vamos a ver como podemos mover a producción este servidor local. Una vez iniciado Debian 10 actualizamos el sistemas, agregamos el repositorio e instalamos FreeSwitch. apt-get update &amp;&amp; apt-get install -y gnupg2 wget lsb-releasewget -O - https://files.freeswitch.org/repo/deb/debian-release/fsstretch-archive-keyring.asc | apt-key add -echo \"deb http://files.freeswitch.org/repo/deb/debian-release/ `lsb_release -sc` main\" &gt; /etc/apt/sources.list.d/freeswitch.listecho \"deb-src http://files.freeswitch.org/repo/deb/debian-release/ `lsb_release -sc` main\" &gt;&gt; /etc/apt/sources.list.d/freeswitch.listapt-get update &amp;&amp; apt-get install -y freeswitch-meta-allLuego levantamos FreeSwitch y ya que estamos habilitamos el servicio en el arranque y comprobamos que funciona correctamente: systemctl start freeswitchsystemctl enable freeswitch.servicefs_cliEvidentemente tenemos que ser root o lanzar como “sudo” Si todo es correcto veremos lo siguiente: Configuración y primera llamada Ya es posible realizar nuestra primera llamada. Es necesario tener instalado algún dispositivo SIP.Yo voy a usar Zoiper, además en su versión 3, que me gusta más que la 5 de momento. Os dejo un enlace por si queréis descargar la misma versión ZOIPER.Primero vamos a comprobar que en FreeSwitch no existe ningún registro: freeswitch@debian&gt; show registrationsDevolverá 0 total Posteriormente vamos a registrar nuestra primera extensión “1000”. Así que tenemos que crear en Zoiper una nueva cuenta SIP:   Usuario: 1000  Contraseña: 1234  Domain: 192.168.0.15 (tendrás que poner la IP asignada a tu Sistema)Si tienes éxito podemos volver a lanzar el comando show registrations y veremos que nos muestra datos de nuestra extensión recién registrada además de 1 total.Ahora podrías añadir por ejemplo otra extensión como la 1001 o simplemente podemos comprobar que todo funciona llamando a algunas extensiones que FreeSwitch ha creado y enrutado de manera predeterminada.             Header1      Header2                  5000      IVR              4000      Voicemail              9196      Eco test              9195      Eco test con 5 segundos de retardo              9197      Un pitido terrible              9198      Tetris (wav)              9664      Música de espera (MOH)      Hay muchos más números pero de momento si todo esto funciona correctamente podemos estar satisfechos. Conclusión Bueno, pues aunque parezca que ya que podemos llamar tenemos un 70% del trabajo realizado, creo que con esto no llegamos ni la 1%.La configuración es realmente compleja y vamos a ir aprendiendo como usarlo. En un principio no vamos a instalar ningún programa adicional para manejar la configuración sino que todo lo vamos a realizar a mano. Ya sabes, a base de golpes se aprende. Si lo que quieres es tener una PBX simple pequeña te recomiendo que busques FreePBX u otro tipo de solución. Para dar servicio de telefonía a un pequeño negocio no necesitas FreeSwitch, sino otro tipo de PBX con una buena interfaz, fácil de usar y más completa en lo referente a servicios para el usuario. Nosotros más adelante si vamos a conectarle otra PBX como FreePBX, vamos a crear proveedores, posiblemente instalemos Pyfreebilling, instalaremos un servidor de trazas como Homer y realizar test de carga y comparativas. ¡Nos vemos en el siguiente post! ","categories": ["FreeSwitch"],
        "tags": ["FreeSwitch","PBX","VoIP","SIP"],
        "url": "https://noobchamp.github.io/freeswitch/Freeswitch-produccion-pbx/"
      },{
        "title": "FreeSwitch: Variables",
        "excerpt":"Introducción Como en cualquier otro software, las variables proporcionan poder acceder a un valor cuando se solicita sin tener asignarla contínuamente.Lo más importante aquí es saber que FreeSwitch carga las variables en memoria, por tanto, cuando accedes a esta variable lo estás haciendo en la memoria del sistema. Tipos Básicamente son dos tipos de variables: variable GLOBAL (Global variables) y variable de CANAL (Channel variable).En el primer caso GLOBAL, la variable es accesible para todos lo canales mientras en el segundo caso CANAL la variable es solo accesible en el contexto del canal. Por ejemplo, una variable global sería la IP que usa el sistema local_ip_v4, siempre vamos a poder acceder a ella en cualquier parte.Como ejemplo de una variable de canal sería por ejemplo una asignada para el número de destino al que se está llamando destination_number, asignada para manejar la llamada en el dialplan. Esta variable será reasignada en cada llamada, en cada canal, porque no va a obtener un valor fijo, eso lo tenemos claro en este punto. Acceder a las variables Se accedes a las variables con formato ${variable}. Como en el ejemplo anterior, vamos a comprobar nuestra variable local_ip_v4, podemos hacerlo de dos formas:Desde la consola de FreeSwitch con el comando eval + ${variable} (ejecutando fs_cli): freeswitch@debian&gt; eval ${local_ip_v4}192.168.0.15O desde la misma shell, con fs_cli -x + eval ${variable}: root@debian:/home/oliva# fs_cli -x 'eval ${local_ip_v4}'192.168.0.15¡Ojo! Debes usar las comillas simple y no doble para que no sea interpretado por bash Asignación y re-asignación En los archivos de configuración será referidas con un doble $ $${variable}, sólo en los archivos de configuración para sólo variables globales.Para el resto como hemos visto anteriormente nos referimos con un sólo $ ${variable}. Podemos referirnos tanto a variables globales como variables de canal.Entonces…¿Es posible re-asignar una variable global? Rotundamente sí. freeswitch@debian&gt; global_getvar local_ip_v4192.168.0.15freeswitch@debian&gt; global_setvar local_ip_v4=1.1.1.1+OKfreeswitch@debian&gt; global_getvar local_ip_v41.1.1.1freeswitch@debian&gt;Esta variable global local_ip_v4 se encuentra definida en el archivo vars.xml (en realidad no es así del todo pero luego se aclara). Le hemos dicho a FreeSwitch que su IP local es 1.1.1.1. Las consecuencias son catastróficas, nuestro teléfono ha dejado de registrar, en el anterior capítulo tienes como comprobar o simplemente el teléfono te va a devolver un error 403 - Forbidden. Algo interesante, si hacemos reloadxml recargará la configuración de FreeSwitch pero la variable seguirá definida como 1.1.1.1. El comando debería recargar los archivos XML como el dialplan, además de vars.xml pero no es así en caso de variables pre-processor. Vamos a comprobar varias cosas:   Abrimos el archivo /etc/freeswitch/vars.xml -&gt; Aquí vamos a ver las variables como PRE-PROCCESS, un ejemplo que vas a recordar.&lt;X-PRE-PROCESS cmd=\"set\" data=\"default_password=1234\"/&gt;  Visualiza el contenido de /var/log/freeswitch/freeswitch.xml.fsxml. Este archivo son todas las variables que se han cargado al iniciar FreeSwitch.global_setvar ha modificado una variable “pre-cargada” por el sistema que no puede ser recargada. Ahora solo tenemos dos caminos para que nuestro FreeSwitch funcione correctamente de nuevo permitiendo registrar los dispositivos: O bien volvemos a lanzar el comando con el parámetro correcto o bien reiniciamos el servicio. Debes de tener en cuenta que en producción el reinicio va a provocar la caída de todas las llamadas en curso. Estamos en un desarrollo así que….alegría. –La consola de FreeSwitch estará devolviendo un warning por este problema que hemos provocado– Ahora vamos a darle una vuelta más. En el archivo vars.xml no aparece definida &lt;X-PRE-PROCESS cmd=\"set\" data=\"local_ip_v4=192.168.0.15\"/&gt;Si en algún momento te paraste a leer, habrás visto que indica expresamente que una serie de variables, entre ellas local_ip_v4 han sido calculadas por FreeSwitch dinámicamente y definidas como variables globales.   Repite los pasos anteriormente pero en vez de cambiar la variable local_ip_v4, cambia la variable default_password.Luego recarga configuración XML reloadxml y comprueba de nuevo el valor de la variable.¡Sí! En este caso la variable ha sido cargada nuevamente y ahora devuelve nuevamente 1234 sin tener que recargar FreeSwitch   Puede que la pregunta que te ronda ahora es para qué tanto follón y lío con esto de las variables. Bueno, según como vayas a montar tu sistema, vas a necesitar conocer si es necesario definir ciertas variables del sistema como la ip local. Puedes enrutar tanto por IP o puede que tu IP sea dinámica y vayas a registrar tus terminales mediante DNS y así no es necesario asignar un IP fija local. En fin, por una parte me va a obligar a indicar una IP fija en mi DNS en la interfaz local de mi FreeSwitch o bien por otra a configurar un nombre de dominio y tener la libertad de tener una ip dinámica. Cada cual tiene sus ventajas e inconvenientes y cuando se trata de interfaz local pues no es verdaderamente útil que digamos pero piensa en lo siguiente: Estamos en un entorno local de desarrollo pero la idea es tener a usuarios en cualquier parte del mundo. ¿Es más factible que registren contra una IP pública o contra un dominio típico como voip.empresa.com Esto abre un mundo de posibilidades ya que tener un nuevo cliente en cualquier parte y si tuvieras algún problema con la IP no te va a importar ya que no necesitarás re-configurar los terminales. También ahorramos un pequeño coste por pagar IP fija en algunos casos. En el siguiente post habrá un poco de teoría sobre FreeSwitch para entender el funcionamiento un poquito mejor. ¡Nos vemos! ","categories": ["FreeSwitch"],
        "tags": ["FreeSwitch","PBX","VoIP","SIP","Variables"],
        "url": "https://noobchamp.github.io/freeswitch/variables-freeswitch/"
      },{
        "title": "VirtualBox Guest Addittions en Red Hat 8 y CentOS 8",
        "excerpt":" Introducción Cuando instalamos Red Hat 8 y/o CentOS 8 en VirtualBox siempre tenemos el inconveniente de que la vista no se ajusta a la ventana.El propósito de este mini tutorial es instalar rápidamente Guest Addiction en RHEL 8 rápidamente. Comandos Antes de ejecutar nada, la máquina debe tener SELINUX en modo permissive o disabled yum groupinstall \"Development Tools\"yum install -y kernel-devel elfutils-libelf elfutils-libelf-develInstalar Guest Additions Simplemente, en la ventana de VirtualBox de la máquina te vas a la pestaña Dispositivos y luego presiona Insertar imagen de CD de las \"Guest Additions\".Saldrá un diálogo en la máquina, presiona run.Si el diálogo no te aparece puedes buscarlo en el directorio o si el caso es que no instalaste entorno gráfico “bravo”, tienes que buscar el punto de montaje del cd y lanzar el script VBoxLinuxAdditions.run. Reinicia la máquina… y ya está ¡Nos vemos! ","categories": ["RHEL","CentOS"],
        "tags": ["Red Hat","CentOS","VirtualBox","Guest Additions"],
        "url": "https://noobchamp.github.io/rhel/centos/RedHat8-VirtualBox/"
      },{
        "title": "SQL*Plus - Historial en Unix-Linux",
        "excerpt":" Introducción Has instalado recientemente Oracle y al usar SQL*Plus no funciona el historial?El prompt de SQL*Plus en Unix y Linux por defecto no tiene historial ni es posible usar las flechas de dirección para moverte hacia delante y atrás además de no poder navegar por el historial como indicábamos. SQL*Plus - Habilitar las fechas de dirección Vamos a instalar rlwrap para solucionar nuestro problema. Requisitos Necesitamos instalar gcc,wget y GNU readline: yum update -yyum install gcc readline-devel -yDescarga e instalación cd /tmp/wget https://github.com/hanslub42/rlwrap/archive/refs/heads/master.zipunzip master.zipcd rlwrap-master/autoreconf --install./configuremakemake testmake installAñadir un alias Vamos a añadir el alias al usuario oracle para que cada vez que usemos SQL*Plus sea junto a rlwrap. cat &lt;&lt; EOF &gt;&gt; /home/oracle/.bashrcalias sqlplus='rlwrap sqlplus'alias rman='rlwrap rman'EOF¡Prueba ahora! su - oraclesqlplus sys / as sysdba¡Nos vemos! ","categories": ["Linux","Oracle"],
        "tags": ["Red Hat","CentOS","Oracle","Sqlplus"],
        "url": "https://noobchamp.github.io/linux/oracle/SQL-plus-prompt/"
      },{
        "title": "Ansible - Tutorial rápido completo 1/2",
        "excerpt":" Introducción Ansible es un herramienta de automatización. No me extenderé en explicar lo que es pero si diré que es muy útil y cada vez es mas usado por administradores sobre todo para automatizar tareas repetitivas o hacer inspección de todos los servidores. En mis inicios de la informática, cada vez que instalabamos un servidor, inmediatamente pasábamos un script (con variables) para definir el hostname, la red, instalar los servicios básicos o los habituales de la organización, etc.. Posteriormente incluso otros para la monitorización, u otros elementos que no eran comunes, como por ejemplo si se trataba de un servidor de aplicaciones. Ansible nos facilita estas tareas mediante plantillas y además nos permite controlar la ejecución, ya sea por fallos, entender qué va a ocurrir u otros factores donde antes “te la jugabas”. Está basado en python :heart: y en este tutorial descubrirás que además de poder personalizar cada tarea hasta el más mínimo detalle, vas a poder simplemente instalar otros “módulos” que van a evitar que tengas que picar todo el código tú solo. Escenario Por el momento, como somos gente molona vamos a trabajar como root. Luego ya veremos…   VirtualBox  Máquina virtual Ansible: Centos 8.5.2 (puedes usar Red Hat ya que Centos a muerto :disappointed:)  IP Ansible 10.0.0.5: He creado una red interna nat. En un capítulo siguiente veremos para qué pero puedes usar el puente o el nat normal para tener acceso a internet.  Máquina virtual nodo1, nodo2, nodo3: Centos 8.5.2 Clonadas desde una plantilla  IP nodoX: 10.0.0.1X  No olvides tener todo actualizado    yum clean all &amp;&amp; yum update -y      Instalar ansible [root@ansible ~]# yum install python39[root@ansible ~]# pip3 install ansible[root@ansible ~]# pip3 install argcomplete# Vamos a generar ya la clave ssh para copiarla a otro servidor, cuando proceda.# Le das a INTRO (todo por defecto)[root@ansible ~]# ssh-keygen -t rsa -b 4096Ansible ¡Ahora si! Ansible por defecto te indica que el archivo de inventario es en /etc/ansible/hosts.Vamos a pasar de esto y hacer nuestro propio ansible, nuestro propio inventario en yamel.Para resumir, me he creado mi usuario oliva y he craeado /home/oliva/miansible.yml (aun seguimos como root): all:  hosts:  children:    micluster:      hosts:        nodo1:          ansible_host: 10.0.0.11        nodo2:          ansible_host: 10.0.0.12        nodo3:          ansible_host: 10.0.0.13Estas entradas como se puede ver, es para crear un cluster de 3 nodos, al que invocaremos con el nombre cluster. Posteriormente seguiremos aumentando este inventario. Por tanto debemos tener las entradas correspondientes en /etc/hosts: 127.0.0.1   localhost localhost.localdomain ansible10.0.0.11   nodo1.micluster nodo110.0.0.12   nodo2.micluster nodo210.0.0.13   nodo3.micluster nodo3Vamos a hacernos amigos de los nodos, copiamos la clave ssh para que no pida contraseña [root@ansible ~]# ssh-copy-id root@nodo2/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \"/root/.ssh/id_rsa.pub\"The authenticity of host 'nodo2 (10.0.0.12)' can't be established.ECDSA key fingerprint is SHA256:VZ5ZJ4xh0PEgUe1twpgZEU0dsjtTSzWey5tVajSx1nA.Are you sure you want to continue connecting (yes/no/[fingerprint])? yes/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysroot@nodo2's password:Number of key(s) added: 1Now try logging into the machine, with:   \"ssh 'root@nodo2'\"and check to make sure that only the key(s) you wanted were added.Esto para los 3 nodos evidentemente… Y ahora vamos a hacer la primera prueba, un ping a todos. He apagado el nodo2 para probar: [root@ansible ~]# ansible all -m ping -i /home/oliva/miansible/inventory.ymlnodo1 | SUCCESS =&gt; {    \"ansible_facts\": {        \"discovered_interpreter_python\": \"/usr/libexec/platform-python\"    },    \"changed\": false,    \"ping\": \"pong\"}nodo3 | SUCCESS =&gt; {    \"ansible_facts\": {        \"discovered_interpreter_python\": \"/usr/libexec/platform-python\"    },    \"changed\": false,    \"ping\": \"pong\"}nodo2 | UNREACHABLE! =&gt; {    \"changed\": false,    \"msg\": \"Failed to connect to the host via ssh: ssh: connect to host 10.0.0.12 port 22: No route to host\",    \"unreachable\": true}  -m: modulo de ansible  -i: inventario, recuerda que hemos especificado un inventario, por defecto sería /etc/ansible/hosts  -u: En caso de que no estuvieramos como root especificamos -u root o el usuario con el que hayamos realizado el ssh-copy-id.  Funciona con el mismo usuario en origen a no ser que se especifique bien por línea de comandos o se puede establecer en el archivo de inventario de esta forma (aunque la vamos a descartar, en la siguiente parte veremos por qué):    all:  hosts:  children:micluster:  hosts:    nodo1:      ansible_host: 10.0.0.11    nodo2:      ansible_host: 10.0.0.12    nodo3:      ansible_host: 10.0.0.13  vars:    ansible_user: root        Como se puede ver, la sintaxis de yame hace que según la identación, pueda establecerla para los host de clustero para todos los hosts en adelante si no tenemos pensado trabajar con otro usuario que no sea root.   En la siguiente parte vamos a ver los playbooks, roles, tags, handlers…Además empezaremos a trabajar con ansible-galaxy. ¡Adiós! ","categories": ["Ansible","Linux"],
        "tags": ["Red Hat","CentOS","Ansible"],
        "url": "https://noobchamp.github.io/ansible/linux/Ansible-configuracion-inicial-1/"
      },{
        "title": "Ansible - Tutorial rápido completo 2/2",
        "excerpt":" Introducción En el anterior post vimos lo básico de Ansible. Aunque con nuestro inventario podemos lanzar prácticamente cualquier módulo por línea de comandos, lo ideal es hacer una estructura y usar todo lo disponible a nuestro alcance. Ahora vamos a ver playbooks, handlers, tags, collections, vault, roles y ansible-galaxy. Estas cosas son las que hacen que ansible sea tan útil.Vamos a ver cada uno y entremedias veremos otras cosillas como el vault, al final va a ser un revuelto pero la cosa es ver cómo trabajan juntos puesto que por separado no es eficiente.   Las opciones de los comandos se han explicado en el anterior post.Recuerda que la opción -C va a simular la ejecución pero no la llevará a cabo. Playbook Un playbook nos sirver para ejecutar específicas tareas sobre específicos servidores. Por supuesto tiene sintaxis yamel. Mejor vamos a explicar con un ejemplo, vamos a crear el primer playbook. Como vimos anteriormente todo lo hacemos como root pero vamos a crear el usuario ansible y copiar la rsa a cada máquina. ---- hosts: micluster  tasks:    - name: Crear el usuario ansible      user:        name: ansible        shell: /bin/bash        #password:        generate_ssh_key: yes        ssh_key_bits: 2048        ssh_key_file: .ssh/id_rsaY comprobamos que pasaría (lanzamos a un solo nodo): [root@ansible miansible]# ansible-playbook crearusuario.yml -i inventory.yml -l nodo1 -CPLAY [micluster] *******************************************************************************************************************************************************************************TASK [Gathering Facts] *************************************************************************************************************************************************************************ok: [nodo1]TASK [Crear el usuario ansible] ****************************************************************************************************************************************************************changed: [nodo1]PLAY RECAP *************************************************************************************************************************************************************************************nodo1                      : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   Como vemos en el playbook, no tenemos clave para este usuario, en Linux se puede crear el usuario pero no proporcionar contraseña.Esa es la línea que tenemos comentada, pero como no queremos pasar contraseñas en texto plano vamos a la siguiente cuestión. Vault No es más que un gestor de contraseñas (por así llamarlo). Se usa para cifrar las claves y no enviarlas en texto plano. Además te permite poder subir tu proyecto incluida las contraseñas puesto que usa una contraseña maestra. Primero vamos a crear el archivo [root@ansible miansible]# ansible-vault create vault.ymlNew Vault password: Confirm New Vault password: # En mi caso he puesto secreto123, sera la contraseña maestraDirectamente entra en el editor vi (puedes cambiarlo), si no sabes salir pulsa esc y :wq.He agregado la entrada: ansible_usuario: ans1bl3_p4ssComprobamos que ahora está encriptado [root@ansible miansible]# cat vault.yml $ANSIBLE_VAULT;1.1;AES256346461396232663338653962346262656664373833326165383636653565393736363766303030323235656132326633333831356463613837386635353736340a356331646439373139366438316539356139646436323735623430323861363136313666343536663065656631636139353134353461663163366363313865350a63363463346435363764323335323736616436303338653735613765346635356530636132356431626239393663613461346165396530343666626431336632Ahora si podemos añadir una contraseña, por ejemplo ---- hosts: micluster  tasks:    - name: Crear el usuario ansible      user:        name: ansible        shell: /bin/bash        password: micomtraseña        generate_ssh_key: yes        ssh_key_bits: 2048        ssh_key_file: .ssh/id_rsaEsto nos va a reportar un problema [root@ansible miansible]# ansible-playbook crearusuario.yml -i inventory.yml -l nodo1 -CPLAY [micluster] *******************************************************************************************************************************************************************************TASK [Gathering Facts] *************************************************************************************************************************************************************************ok: [nodo1]TASK [Crear el usuario ansible] ****************************************************************************************************************************************************************[WARNING]: The input password appears not to have been hashed. The 'password' argument must be encrypted for this module to work properly.changed: [nodo1]PLAY RECAP *************************************************************************************************************************************************************************************nodo1                      : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   Hay varias soluciones, la más simple que sería usar mkpasswd o openssl para generar una clave SHA-512.El propósito del vault era no depender de estas cosas, por tanto hay que modificar el playbook para indicarle que vamos a usar el playbook y que la contraseña será una variable ---- hosts: micluster  vars_files:    - vault.yml  tasks:    - name: Crear el usuario ansible      user:        name: ansible        shell: /bin/bash        password: \"{{ ansible_usuario | password_hash('sha512') }}\"        generate_ssh_key: yes        ssh_key_bits: 2048        ssh_key_file: .ssh/id_rsa  Como se aprecia, mediante una tubería hemos cifrado a SHA-512 el texto plano que teníamos en el vault. Puesto que vamos a usar el vault ahora el comando es distinto, puesto que tenemos que indicar que la contraseña maestra para abrirlo [root@ansible miansible]# ansible-playbook crearusuario.yml -i inventory.yml -l nodo1 -C --ask-vault-passVault password: PLAY [micluster] ......nodo1                      : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   Dirás que es un peñazo tener que poner la contraseña o que hace que lanzar una tarea automática sea imposible puesto que un prompt nos va a pedir la contraseña. Explora la opción --vault-password-file ~/.vault_pass.txt en la que podemos tener un archivo con los permisos correctos en el sitio correcto para que sea accesible por quien queremos. Roles En estos momentos nos planteamos ciertas preguntas.¿Para cada cierto tipo de acción necesitamos un playbook?¿Qué ocurre si no quiero ejecutar un playbook completo, solo una parte?¿Voy a juntar un montón de playbooks? La respuesta es crear roles. A modo de hacer nuestro Ansible modular.Vemos que estamos creando un cluster y vamos a tener que añadir tareas relativas a ellos. Pero la cuestión, no todo van a ser las mismas tareas, los mismos SO, los mismos elementos en general… Lo ideal es hacer roles que realicen tareas generales que puedan valer para cualquier servidor. Por ejemplo: En nuestro caso haremos un rol para englobar las tareas relacionadas con SSH. Posteriormente podríamos crear otro rol para crear clúster Pacemaker, otro para servidores web… Vamos a crear el primer rol, se puede hacer manualmente o mediante el comando ansible-galaxy Ansible Galaxy Etiquetado para compartir con la comunidad roles y colecciones entre otros pero además nos va a permitir crear nuestras estructuras. [oliva@ansible miansible]$ ansible-galaxy init ssh- Role ssh was created successfully[oliva@ansible miansible]$ ls -la sshtotal 8drwxrwxr-x. 10 oliva oliva  154 Sep 22 20:51 .drwxrwxr-x.  3 oliva oliva   79 Sep 22 20:51 ..drwxrwxr-x.  2 oliva oliva   22 Sep 22 20:51 defaultsdrwxrwxr-x.  2 oliva oliva    6 Sep 22 20:51 filesdrwxrwxr-x.  2 oliva oliva   22 Sep 22 20:51 handlersdrwxrwxr-x.  2 oliva oliva   22 Sep 22 20:51 meta-rw-rw-r--.  1 oliva oliva 1328 Sep 22 20:51 README.mddrwxrwxr-x.  2 oliva oliva   22 Sep 22 20:51 tasksdrwxrwxr-x.  2 oliva oliva    6 Sep 22 20:51 templatesdrwxrwxr-x.  2 oliva oliva   39 Sep 22 20:51 tests-rw-rw-r--.  1 oliva oliva  539 Sep 22 20:51 .travis.ymldrwxrwxr-x.  2 oliva oliva   22 Sep 22 20:51 vars  Aqui vemos el árbol creado en la carpeta ssh el cual es nuestro rol para tareas de SSH. ¿Te suena tasks? Son las tareas que ejecutamos en el playbook, ahora van en este archivo. Por tanto vamos a copiar el contenido del playbook, en la sección tasks aquí # tasks file for ssh- name: Crear el usuario ansible  user:    name: ansible    shell: /bin/bash    password: \"{{ ansible_usuario | password_hash('sha512') }}\"    generate_ssh_key: yes    ssh_key_bits: 2048    ssh_key_file: .ssh/id_rsaMientras que el playbook crearusuario.yml quedará asi ---- hosts: micluster  vars_files:    - vault.yml  roles:    - sshEjecutamos de nuevo [root@ansible miansible]# ansible-playbook crearusuario.yml -i inventory.yml -l nodo1 -C --ask-vault-pass Y vemos que se completa correctamente. ¡Ya estamos trabajando con nuestro primer rol TAGS Necesitamos al menos agregar una segunda tarea para entender los tags. ---# tasks file for ssh- name: Instalar la última versión de ssh  yum:    name: openssh-server, openssh-clients    state: latest  tags: instalar    - name: Crear el usuario ansible  user:    name: ansible    shell: /bin/bash    password: \"{{ ansible_usuario | password_hash('sha512') }}\"    generate_ssh_key: yes    ssh_key_bits: 2048    ssh_key_file: .ssh/id_rsa  tags: usuariosSi volvemos a ejecutar, vamos a ver que se ejecutaran naturalmente ambas tareas.Podemos especificar dentro del rol que tareas queremos especificar. Como sabemos que ya está instalado SSH vamos a decirle que ejecute solamente la tarea de crear el usuario ansible.Usa el parámetro -t para indicar los tags. [root@ansible miansible]# ansible-playbook -v crearusuario.yml -i inventory.yml -l nodo1 -C -t usuarios --ask-vault-pass No config file found; using defaultsVault password: PLAY [micluster] ************************************************************************************************************************************************************************************************************TASK [Gathering Facts] ******************************************************************************************************************************************************************************************************ok: [nodo1]TASK [ssh : Crear el usuario ansible] ***************************************************************************************************************************************************************************************changed: [nodo1] =&gt; {\"changed\": true}PLAY RECAP ******************************************************************************************************************************************************************************************************************nodo1                      : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0     También puedes hacer el efecto contrario –skip-tags No hay manera fácil, por así decirlo, de incluirlo en el playbook. Hay formas pero son más complejas.Esto es una de las cosas, bajo mi punto de vista, están un poco verdes. Collections Las coleciones son contenidos que pueden ser playbooks, roles, módulos y plugins.Básicamente se ha creado una comunidad para ahorrarte tareas como las que hasta ahora estamos haciendo (muy normales, nada específico).Toda la info se encuentra en la página oficial de Ansible. Vamos a hacer una pequeña prueba, vamos a instalar un motd de GoKEV [root@ansible miansible]# ansible-galaxy install gokev.motd-splash -p /home/oliva/miansible/Starting galaxy role install process- downloading role 'motd-splash', owned by gokev- downloading role from https://github.com/GoKEV/motd-splash/archive/master.tar.gz- extracting gokev.motd-splash to /home/oliva/miansible/gokev.motd-splash- gokev.motd-splash (master) was installed successfully[root@ansible miansible]# ll gokev.motd-splash/total 4drwxr-xr-x.  2 root root   22 Sep 23 21:00 defaultsdrwxr-xr-x.  2 root root  163 Sep 23 21:00 filesdrwxr-xr-x.  2 root root   22 Sep 23 21:00 handlersdrwxr-xr-x.  2 root root   50 Sep 23 21:00 metadrwxr-xr-x. 10 root root  135 Sep 23 21:00 motd-splashdrwxr-xr-x.  9 root root  118 Sep 23 21:00 prep-new-vm-rw-rw-r--.  1 root root 2793 May  3 19:37 README.mddrwxr-xr-x.  2 root root   22 Sep 23 21:00 tasksdrwxr-xr-x.  2 root root  152 Sep 23 21:00 templatesdrwxr-xr-x.  2 root root   39 Sep 23 21:00 testsdrwxr-xr-x.  2 root root   22 Sep 23 21:00 varsdrwxr-xr-x.  8 root root  105 Sep 23 21:00 vm-rebootdrwxr-xr-x.  8 root root  120 Sep 23 21:00 vmware-provisionEn el readme indica que puedes incluiir el rol gokev.motd-splash en un playbook.Añadimos a nuestro playbook ---- hosts: micluster  vars_files:    - vault.yml  roles:    - ssh    - gokev.motd-splash  vars:    motd_template_file: templates/motd_redhatY ejecutamos con –diff para contemplar las diferencias de las plantillas [root@ansible miansible]# ansible-playbook crearusuario.yml -i inventory.yml -l nodo1 -C --diff --ask-vault-pass Vault password: PLAY [micluster] ****************************************************************************************************************************************************************************************TASK [Gathering Facts] **********************************************************************************************************************************************************************************ok: [nodo1]TASK [ssh : Instalar la última versión de ssh] **********************************************************************************************************************************************************ok: [nodo1]TASK [ssh : Crear el usuario ansible] *******************************************************************************************************************************************************************changed: [nodo1]TASK [gokev.motd-splash : Define the custom MOTD file if this is a CentOS system] ***********************************************************************************************************************skipping: [nodo1]TASK [gokev.motd-splash : Define the custom MOTD file if this is a RHEL system] *************************************************************************************************************************skipping: [nodo1]TASK [gokev.motd-splash : Define the MOTD file for any non-RHEL and non-CENT machine] *******************************************************************************************************************skipping: [nodo1]TASK [gokev.motd-splash : motd template] ****************************************************************************************************************************************************************--- before: /etc/motd+++ after: /root/.ansible/tmp/ansible-local-4924bw_vip6k/tmpvwnd3yzd/motd_redhat@@ -0,0 +1,27 @@+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+@@@@@@@@@@@###########%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+@@@@@@@@@@###############%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+@@@@@@@@@#################@@@@@@@@@@@@       @@@@@@@@@@@@@@@@@@@@  @@@@   @@@@@   @@@@@@@@@@@@@@@@@@@@+@@@@@@@@@##################@@@@@@@@@@@   @@@   #@@@@@@@@@@@@@@@@@  @@@@   @@@@@   @@@@@@@@@@@   @@@@@@+@@@#####   &amp;###############@@@@@@@@@@@   @@@@   @       @@@        @@@@   @@@@@   @       &amp;@       @@@+@@#######      ############@@@@@@@@@@@         @   @@@   @   @@@@  @@@@           @@@@@@   @@   @@@@@@+@@@#########                ###@@@@@@@   @@   @@     ,,,,@   @@@@  @@@@   @@@@@   @   **   @@   @@@@@@+@@@@@###########%         ######@@@@@@   @@@   @@       @@@        @@@@   @@@@@   @        @@&amp;    *@@@+@@@@@@@#########################@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+@@@@@@@@@@@####################&amp;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+@@@@@@@@@@@@@@@@#############@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@++                              HOSTNAME  ===&gt;  centos +                             IP ADDRESS ===&gt;  10.0.0.11 +               --------------------------------------------------------------------++               KERNEL          4.18.0-348.7.1.el8_5.x86_64+               ARCH            x86_64+               MACHINE         innotek GmbH :: 1.2+               COREs           2++               --------------------------------------------------------------------+changed: [nodo1]TASK [gokev.motd-splash : issue template] ***************************************************************************************************************************************************************--- before: /etc/issue+++ after: /root/.ansible/tmp/ansible-local-4924bw_vip6k/tmpytb0z_ud/issue@@ -1,3 +1,12 @@-\\S-Kernel \\r on an \\m+  ###########################   WARNING!   ########################### +              YOU ARE ABOUT TO CONNECT TO centos!!++The computer you are about to use is company owned and is intended to be used+for official company business. As such, the company reserves the right to+monitor all activity on all company provided equipment and services. All use+of this machine must comply with company IT policies,  available from HR.++             ALL ACTIVITIES IN THIS SYSTEM ARE MONITORED!++  ###########################   WARNING!   ###########################changed: [nodo1]PLAY RECAP **********************************************************************************************************************************************************************************************nodo1                      : ok=5    changed=3    unreachable=0    failed=0    skipped=3    rescued=0    ignored=0   Handlers Te va a permitir realizar una acción en cadena, es decir, si algo ha cambiado, se reinicia el servicio, pero no lo hará si no hay un cambio. Si cambiamos el archivo de configuración de SSH necesitaremos reiniciar el servicio para que los cambios sean efectivos. Por tanto, es necesario reiniciar. En la página oficial podemos ver un ejemplo muy claro. ¡Adiós! ","categories": ["Ansible","Linux"],
        "tags": ["Red Hat","CentOS","Ansible"],
        "url": "https://noobchamp.github.io/ansible/linux/Ansible-configuracion-inicial-2/"
      },{
        "title": "Red Hat - Instalar un repositorio local",
        "excerpt":" Introducción Tener un servidor conectado a Red Hat, no siempre es posible o no queremos subscribirlo por varios motivos:   Nos encontramos en una red sin acceso a internet.  Se trata de una máquina virtual o pruebas.  La velocidad de red tiene poco caudal.  Nos gusta la aventura…Podemos instalar un repositorio local, o bien teniendo un servidor que SI esté subscrito o desde un CD oficial.¿Cuál es la diferencia? Evidentemente, teniendo un cd como repositorio, no tenemos actualizaciones de paquetes, sin embargo, no será necesario hacer un pago en Red Hat.El inconveniente de todo esto, será la cantidad de espacio que vamos a necestar, que dependerá de cuántas versiones querramos tener. Desarrollado a través de Red Hat. Preparando el terreno Subscripción a Red Hat Por supuesto, tienes que tener cuenta en RHEL. No es necesario previo pago, puede obtener una licencia de pruebas o un sadbox. # Aunque la versión no tiene por qué ser la última, podríamos tener un 8.1 y descargar cualquier versión 8.Xroot@repository:~#cat /etc/os-releaseNAME=\"Red Hat Enterprise Linux\"VERSION=\"8.8 (Ootpa)\"ID=\"rhel\"ID_LIKE=\"fedora\"VERSION_ID=\"8.8\"PLATFORM_ID=\"platform:el8\"PRETTY_NAME=\"Red Hat Enterprise Linux 8.8 (Ootpa)\"ANSI_COLOR=\"0;31\"CPE_NAME=\"cpe:/o:redhat:enterprise_linux:8::baseos\"HOME_URL=\"https://www.redhat.com/\"DOCUMENTATION_URL=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8\"BUG_REPORT_URL=\"https://bugzilla.redhat.com/\"REDHAT_BUGZILLA_PRODUCT=\"Red Hat Enterprise Linux 8\"REDHAT_BUGZILLA_PRODUCT_VERSION=8.8REDHAT_SUPPORT_PRODUCT=\"Red Hat Enterprise Linux\"REDHAT_SUPPORT_PRODUCT_VERSION=\"8.8\"# Registro en RHELroot@repository:~#subscription-manager registerRegistering to: subscription.rhsm.redhat.com:443/subscriptionUsername: oliva_rhPassword: ******The system has been registered with ID: 3aa74c4f-2e84-439e-aa37-xxxxxxxxxxxxThe registered system name is: repository# Aquí vemos el acceso a cualquier versión de la 8root@repository:~#subscription-manager release --list+-------------------------------------------+          Available Releases+-------------------------------------------+88.08.18.28.38.48.58.68.78.8# Por el momento no hemos definido ningunaroot@repository:~#subscription-manager release --showRelease not setPor otro lado, tampoco hemos habilitado ningún repositorio.Podemos listar todos los repositorios disponibles.Habilitaremos los que nos interese…En mi caso, pondré dos básicos:   rhel-8-for-x86_64-baseos-rpms  rhel-8-for-x86_64-appstream-rpmsroot@repository:~#subscription-manager repos --list | more+----------------------------------------------------------+    Available Repositories in /etc/yum.repos.d/redhat.repo+----------------------------------------------------------+Repo ID:   rhel-atomic-7-cdk-3.10-rpmsRepo Name: Red Hat Container Development Kit 3.10 /(RPMs)Repo URL:  https://cdn.redhat.com/content/dist/rhel/atomic/7/7Server/$basearch/cdk/3.10/osEnabled:   0Repo ID:   rhocp-4.9-for-rhel-8-x86_64-source-rpmsRepo Name: Red Hat OpenShift Container Platform 4.9 for RHEL 8 x86_64 (Source RPMs)Repo URL:  https://cdn.redhat.com/content/dist/layered/rhel8/x86_64/rhocp/4.9/source/SRPMSEnabled:   0# Y un largo etc ...root@repository:~#subscription-manager repos --enable=rhel-8-for-x86_64-baseos-rpmsRepository 'rhel-8-for-x86_64-baseos-rpms' is enabled for this system.root@repository:~#subscription-manager repos --enable=rhel-8-for-x86_64-appstream-rpmsRepository 'rhel-8-for-x86_64-appstream-rpms' is enabled for this system.root@repository:~#subscription-manager repos --list--list           --list-disabled  --list-enabled# Listar los repositorios habilitadosroot@repository:~#subscription-manager repos --list-enabled+----------------------------------------------------------+    Available Repositories in /etc/yum.repos.d/redhat.repo+----------------------------------------------------------+Repo ID:   rhel-8-for-x86_64-appstream-rpmsRepo Name: Red Hat Enterprise Linux 8 for x86_64 - AppStream (RPMs)Repo URL:  https://cdn.redhat.com/content/dist/rhel8/$releasever/x86_64/appstream/osEnabled:   1Repo ID:   rhel-8-for-x86_64-baseos-rpmsRepo Name: Red Hat Enterprise Linux 8 for x86_64 - BaseOS (RPMs)Repo URL:  https://cdn.redhat.com/content/dist/rhel8/$releasever/x86_64/baseos/osEnabled:   1Servidor http/https Vamos a necesitar un servidor web, en mi caso, voy a usar Caddy.Puedes usar el mítico httpd o el que te de la gana.Lo voy a colocar todo en la ruta /var/www/repo. root@repository:~#dnf install caddy# Habilitar y iniciar el servicio Caddysystemctl enable caddysystemctl start caddy# Verificar el estado del servicio Caddysystemctl status caddy# Configurar sitiomkdir -p /var/www/repoecho ':8080 {&gt;   root  * /var/www/repo&gt;   file_server {      browse    }&gt; }' &gt; /etc/caddy/Caddyfile.d/repos.caddyfilesystemctl reload caddyDescarga de repositorios Ahora simplemente vamos a establecer la versión con subscription-manager y descargar a nuestra ruta local /var/www/repo. subscription-manager release --set=8.7 &amp;&amp; rm -rf /var/cache/dnf# Vamos a crear una carpeta para la versión 8.8 y otra para la versión 8.7mkdir -p /var/www/repo/8.8mkdir -p /var/www/repo/8.7# Instalar reposyncyum install -y yum-utils#Empezamos a descargar para la versión 8.8subscription-manager release --set=8.8 &amp;&amp; rm -rf /var/cache/dnf reposync -p /var/www/repo/8.8 --download-metadata --repoid=rhel-8-for-x86_64-baseos-rpmsreposync -p /var/www/repo/8.8 --download-metadata --repoid=rhel-8-for-x86_64-appstream-rpms# Para la versión 8.7subscription-manager release --set=8.7 &amp;&amp; rm -rf /var/cache/dnf reposync -p /var/www/repo/8.7 --download-metadata --repoid=rhel-8-for-x86_64-baseos-rpmsreposync -p /var/www/repo/8.7 --download-metadata --repoid=rhel-8-for-x86_64-appstream-rpmsEntonces nos quedará algo así CLientes A la hora de configurar otros servidores para que puedan descargar paquetes desde este repositorio, crearemos el archivo _/etc/yum.repos.d/mi_repositorio.repo [repo-id]baseurl=http://X.X.X.X/versiongpgcheck=0enabled=1# Example[rhel-8-for-x86_64-baseos-rpms]baseurl=http://192.168.1.2/8.8gpgcheck=0enabled=1# etc...Automatización La forma más sencilla, es tener una tarea en cron que lo haga cada cierto periodo.Simplemente es agregar a tu cron, los comandos que hemos visto anteriormente. ¡Adiós! ","categories": ["RHEL","Linux"],
        "tags": ["Red Hat"],
        "url": "https://noobchamp.github.io/rhel/linux/rhel-localrepo/"
      },{
        "title": "Oracle - Recuperar un GAP elevado 'STANDBY'",
        "excerpt":"Recuperar GAP elevado En primer lugar, vamos a comprobar que el GAP es realmente alto como para tomar esta alternativa:STANDBY select thread#, max(sequence#) \"Last Standby Seq Received\" from v$archived_log val, v$database vdb where val.resetlogs_change# = vdb.resetlogs_change# group by thread# order by 1;select thread#, max(sequence#) \"Last Standby Seq Applied\" from v$archived_log val, v$database vdb where val.resetlogs_change# = vdb.resetlogs_change# and val.applied in ('YES','IN-MEMORY') group by thread# order by 1;select PROCESS, STATUS, THREAD#, SEQUENCE#, BLOCK#, BLOCKS from V$MANAGED_STANDBY where SEQUENCE# &gt;0 order by SEQUENCE#;Em los resultados mostrá que el último aplicado con el último recibido es muy alto, por lo que tenemos un GAP como demuestra el proceso MRP0 “MRP0 WAIT_FOR_GAP 1 XXXX  0 0”. Por tanto vamos a resolver la situación haciendo un backup desde la secuencia en la que se encuentra ahora la STANDBY en la PRIMARIA para restablecer la situación.   The system change number (SCN) is Oracle’s clock - every time we commit, the clock increments. The SCN just marks a consistent point in time in the database. Se comprueba el SCN que se ha quedado en la standbySTANDBY select to_char(current_scn) from v$database;-- Por ejemplo 123456789Para el ejercicio voy a crear un directorio específico con suficiente espacio (que tenga los permisos adecuado), por ejemplo /backup/GAP_BACKUP.Ahora en la primaria, hacemos un backup desde el SCN que hemos obtenido con RMAN.PRIMARY RMAN&gt; run {2&gt; allocate channel c1 type disk format '/backup/GAP_BACKUP/%U.bkp';3&gt; backup incremental from scn 123456789 database;4&gt; }También tenemos que hacer una copia del controlfile para la stadby en la primaria.PRIMARY alter database create standby controlfile as '/backup/GAP_BACKUP/ctl_standby.ctl';Copiamos los ficheros al servidor de destino, previamente he creado una carpeta en el servidor de destino llamada /backup/GAP_RECOVER. Por tanto copiará el/los archivos .bkp y el ctl_standby.ctl scp /backup/GAP_BACKUP/* oracle@serverSTANDBY:/backup/GAP_RECOVER/Ahora vamos realizamos las operaciones de restore en la standby.STANDBYParamos la BBDD -- Localizamos el controlfile actual (o lo normal es que tengas varios)SHOW PARAMETER control_files;-- Por ejemplo lo tenemos ubicado en /u01/oradata/control01.ctl y /u02/oradata/control02.ctl-- Para la BBDDshutdown immediate;-- Levantar sin montarstartup nomount;Ahora movemos los controlfile y copiamos con el que hemos traído desde el servidor de la PRIMARIA mv /u01/oradata/control01.ctl /u01/oradata/control01.ctl.$(date +\"%Y-%m-%d\")mv /u02/oradata/control02.ctl /u02/oradata/control02.ctl.$(date +\"%Y-%m-%d\")cp /backup/GAP_RECOVER/ctl_standby.ctl /u01/oradata/control01.ctlcp backup/GAP_RECOVER/ctl_standby.ctl /u02/oradata/control02.ctlMontar nuevamente alter database mount standby database;El próximo paso es recuperar desde RMAN # Indicamos la ubicaciónrman target /RMAN&gt; catalog start with '/backup/GAP_RECOVER';# Iniciar el restoreRMAN&gt; recover database;...Se ha finalizado recover a las...En este punto hemos resuelto el GAP, ahora solo tenemos que volver a indicar que inicie el proceso alter database recover managed standby database disconnect from session;Podemos comprobar si está aplicando logs desde la consulta que hicimos al principio “Last Standby Seq Received” “Last Standby Seq Applied”. También podemos probar a rotar en la PRIMARIA para comprobar que la secuencia continúa recibiendo/aplicandoPRIMARY alter system switch logfile;Y de nuevo comprobar la secuencia en STANDBY ¡Nos vemos! ","categories": ["Oracle","Rman"],
        "tags": ["Oracle","rman"],
        "url": "https://noobchamp.github.io/oracle/rman/Recuperar-GAP-elevado/"
      },{
        "title": "Montar un VDO o disco de deduplicación",
        "excerpt":"Montar un VDO o disco de deduplicación ¿Qué es? Virtual Data Optimizer (VDO) proporciona una reducción de datos en línea para Linux en forma de deduplicación, compresión y thin provisioning.Documentación español.Los mejores casos para montar este tipo de dispositivo, son el almacenamiento de datos que van a contener los mismos bloques una y otra vez, o explicado de otra forma, los archivos que contienen son similares unos de otros.Pongamos un ejemplo simple: Todos los días realizo un backup de mysql completo que ocupa 5Gb. Las bases de datos suelen cambiar poco diariamente, por lo que si hoy ocupa 5Gb, mañana será de unos 5,2Gb (todo esto es un ejemplo).Por lo tanto, la mayoría de bloques serán exactamente los mismos, el sistema entenderá que hay un bloques duplicados y no los tendrá en cuenta.Esto no es así exactamente ni mucho menos, pero estoy intentado hacerte entender de manera muy simple como funciona para que lo entiendas. Con esta tecnología lo que tenemos es un ahorro de datos, que dependiendo de lo que almacenemos, será mejor o peor, pero nos va a ahorrar mucho espacio. Objetivos   KVM  LVM  NFS/SAMBA o CIFS  iSCSIRequisitos RAM VDO requiere una cantidad fija de 38 MB de RAM y varias cantidades variables:   1.15 MB de RAM por cada 1 MB de tamaño de caché de mapa de bloques configurado. La caché del mapa de bloques requiere un mínimo de 150 MB de RAM.  1.6 MB de RAM por cada 1 TB de espacio lógico.  268 MB de RAM por cada 1 TB de almacenamiento físico gestionado por el volumen.Instalación y creación Instalamos lo paquetes necesatios para el funcionamiento. yum install lvm2 vdo kmod-kvdoEn mi caso, voy a crear un disco para backups.¿En qué consiste cada parámetro?   name: Pues el nombre que quieras dar al volumen, como si le llamas “Pepe”  device: El dispositivo, o sea, el disco. En mi caso estoy destinando un disco nuevo completo (vdb). He insertado un disco de 200Gb.  vdoLogicalSize: El tamaño lógico. Y aquí viene la cuestión existencial… Resulta que mi disco es de 200Gb, según la documentación, es capaz de multiplicar x10 su tamaño lógico. Yo nunca he llegado a obtener esos ratios ni tan siquiera con archivos muy muy similares. Aún así, es muy factible tener un x5 para lo que voy a usarlo. No te preocupes si necesitas ampliar posteriormente tanto parte física como lógica. Esta vez, voy a ser cauto y le voy a proporcionar un x3, o lo que es lo mismo 600Gb. Hay documentación muy interesante hablando de esto, del tamaño de slabs y cosas así…# Crear un volúmenvdo create \\--name=vdo-backup \\--device=/dev/vdb \\--vdoLogicalSize=600GNos responderá algo como… Creating VDO vdo-backup      The VDO volume can address 196 GB in 98 data slabs, each 2 GB.      It can grow to address at most 16 TB of physical storage in 8192 slabs.      If a larger maximum size might be needed, use bigger slabs.Starting VDO vdo-backupStarting compression on VDO vdo-backupVDO instance 2 volume is ready at /dev/mapper/vdo-backupVoy a darle formato, lo quiero como XFS. el -K le indica que no intente descartar bloques (total es nuevo). mkfs.xfs -K /dev/mapper/vdo-backupudevadm settle# para ext4#mkfs.xfs -E nodiscard /dev/mapper/vdo-backup# el comando udevadm settle registra los cambios del sistema con espera activa#Comprobamos que el dispositivo es correctolsblkMontar el voluen manualmente, para probar: mkdir /backup/mount /dev/mapper/vdo-backup /backupumount /backupPuesto que no devuelve ningún error lo voy a añadir al fstab para que arranque # Si no usais vim, estáis perdiendo el tiempo...vim /etc/fstab/dev/mapper/vdo-backup /backup  xfs  defaults,x-systemd.automount,nofail  0 2# Probamos para que no tengamos sustos en un reiniciomount -a# Si ejecutas \"df -h\" verás que el sistema ya tiene ocupación (eso es parte de lo que toma VDO para sus índices y sus cosas)Ahora necesitamos tener activo fstrim, que descartará los bloques sin uso periódicamente un vez a la semana. Aunque si tienes mucha actividad puedes configurarlo para más frecuencia o ejecutarlo vía cron. systemctl enable --now fstrim.timersystemctl status fstrim.timerfstrim.timer - Discard unused blocks once a week   Loaded: loaded (/usr/lib/systemd/system/fstrim.timer; enabled; vendor preset: disabled)   Active: active (waiting) since Wed 2023-05-17 13:24:41 CEST; 3min 15s ago  Trigger: Mon 2023-05-22 01:20:46 CEST; 4 days left     Docs: man:fstrimMay 17 13:24:41 localhost.localdomain systemd[1]: Started Discard unused blocks once a week.Para el que se lo pregunte, no necesitas “discard” en el fstab.Puedes ver incluso, cuando fstrim.timer va a ejecutar el servicio systemctl list-timers fstrim.timerAhora viene la “pena” de todo esto. Tendrás que monitorizar este sistema de archivos dos veces. Si ejecutas el comando vdostats --human-readableDevice                    Size      Used Available Use% Space saving%/dev/mapper/vdo-backup    200.0G      4.1G    195.9G   2%           99%# Te devuelve el espacio físico del dispositivo \"el real\"# si ejecutas un df -h, verás el tamaño que hemos indicado \"lógico\" y por tanto, para tu sistema operativo, ese FS tiene 600Gb.df -h /backup S.ficheros             Tamaño Usados  Disp Uso% Montado en/dev/mapper/vdo-backup   600G   4,3G  596G   1% /backupEntonces, es posible que se llene uno u otro, eso dependerá del tamaño lógico que hemos aplciado y de claro está, ficheros que tengamos almacenados, si son o no más propensos a compresión. Diría que eso es todo.¡¡Nos vemos!! ","categories": ["RHEL","CentOS"],
        "tags": ["Red Hat","CentOS"],
        "url": "https://noobchamp.github.io/rhel/centos/disco-vdo/"
      },{
        "title": "Introducción a Selinux, breve resumen",
        "excerpt":"Iniciación con SELinux 1. Introducción a SELinux   SELinux (Security-Enhanced Linux): Módulo de seguridad para controlar el acceso a recursos en un sistema Linux. Proporciona un mecanismo de control de acceso obligatorio (MAC).  Objetivo: Proteger el sistema y las aplicaciones contra accesos no autorizados, asegurando que los procesos y usuarios solo realicen las acciones para las que están autorizados.Conceptos Clave   Políticas: Conjuntos de reglas que determinan cómo se deben gestionar los accesos a los recursos del sistema. SELinux utiliza políticas predeterminadas, pero se pueden crear personalizadas.  Tipos: Categorías de objetos y procesos (ej: httpd_sys_content_t, var_lib_t).  Usuarios: Representan las entidades que interactúan con el sistema (ej: system_u para el sistema, user_u para usuarios normales).  [!CAUTION]No es recomendable activar selinux en modo “Enforcing” en producción. Primero prueba en modo “Permissive”.— 2. Modos de Operación SELinux tiene tres modos de operación:   Enforcing: Aplica políticas y bloquea accesos no permitidos. Este es el modo recomendado para entornos de producción.  Permissive: Solo registra violaciones sin bloquear accesos, útil para depuración.  Disabled: SELinux desactivado, no se aplican políticas.Comandos Útiles # Verificar estado de SELinuxsestatus# Cambiar a modo permisivosudo setenforce 0# Cambiar a modo enforcingsudo setenforce 13. Contextos de Seguridad Los contextos de seguridad en SELinux son una combinación de cuatro partes:   Usuario: Representa el usuario de SELinux (ej: system_u).  Rol: Rol de seguridad del proceso (generalmente object_r para objetos).  Tipo: Tipo de acceso (ej: httpd_sys_content_t).  Nivel: (opcional) Niveles de seguridad para control de acceso multinivel.Visualización de Contextos # Listar contextos de archivosls -Z /ruta/al/directorio# Listar contextos de procesosps -ZCambiar Contextos # Cambiar contexto de un archivochcon -t httpd_sys_content_t /ruta/al/archivo# Persistir cambios de contextosemanage fcontext -a -t httpd_sys_content_t \"/ruta(/.*)?\"restorecon -Rv /rutaEjemplo # Cambiar el contexto de un archivo en el directorio de Apachechcon -t httpd_sys_content_t /var/www/html/archivo.html4. Auditoría en SELinux SELinux registra eventos y violaciones de políticas en logs ubicados en /var/log/audit/audit.log. La auditoría es esencial para comprender por qué se producen ciertas denegaciones. Comandos Útiles # Buscar eventos de denegaciónausearch -m avc# Explicar la razón de la denegaciónausearch -m avc -ts today | audit2why# Generar una política a partir de eventos de denegaciónausearch -m avc -ts today | audit2allow -M mi_moduloEjemplo # Buscar y explicar por qué Apache no puede acceder a un archivoausearch -m avc -ts today | audit2why5. Booleanos en SELinux Los booleanos son configuraciones que permiten ajustar el comportamiento de las políticas en SELinux. Ejemplo de Booleano Habilitar el acceso de Apache a contenido en el directorio de usuarios: # Listar booleanos disponiblesgetsebool -a# Activar un booleano específicosetsebool -P httpd_enable_homedirs onImportante   Usar la opción -P para hacer cambios persistentes a través de reinicios.6. Creación de Políticas Personalizadas Crear políticas personalizadas permite ajustar SELinux a las necesidades específicas de tu entorno. Estructura de un Archivo de Política module mi_aplicacion 1.0;require {    type var_lib_t;    class dir { read write search open };}# Permitir acceso a directoriosallow unconfined_t var_lib_t:dir { read write search open };Pasos para Crear una Política   Escribir la política en un archivo .te:    nano mi_aplicacion.te        Compilar el archivo:    checkmodule -M -m -o mi_aplicacion.mod mi_aplicacion.tesemodule_package -o mi_aplicacion.pp -m mi_aplicacion.mod        Instalar la política:    sudo semodule -i mi_aplicacion.pp        Verificar instalación:    semodule -l | grep mi_aplicacion      7. Diagnóstico de Problemas Es fundamental para resolver problemas de acceso en sistemas SELinux. Verificar Políticas Cargadas Para ver las políticas activas y su impacto: semodule -lEliminar Políticas Problemáticas # Eliminar un módulo de políticasudo semodule -r nombre_del_moduloConclusión SELinux es una herramienta poderosa para la seguridad en sistemas Linux, proporcionando control de acceso granular a recursos del sistema. Comprender sus componentes y comandos básicos te permitirá gestionar y proteger mejor tus sistemas. Recursos Adicionales   Documentación Oficial de SELinux  Guía de SELinux en RHEL","categories": ["RHEL","CentOS"],
        "tags": ["Red Hat","CentOS"],
        "url": "https://noobchamp.github.io/rhel/centos/Selinux/"
      }]
